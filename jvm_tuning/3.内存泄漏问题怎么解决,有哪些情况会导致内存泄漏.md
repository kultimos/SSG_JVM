# 哪些情况会导致内存泄漏
  ## 堆溢出, java.lang.OutOfMemoryError: Java heap space

  ### 原因
  - 代码中可能存在大对象分配(最后可能得是大数组分配)
  - 可能存在内存泄漏,导致在多次GC之后,还是无法找到一块足够大的内存容纳当前对象

  ### 堆溢出问题的排查思路
  - 针对类似的问题,首先在我们的JVM参数中增加配置[-XX:+HeapDumpOnOutOfMemoryError],用于在java程序运行中产生dump文件,用以后续帮助我们分析
  问题;
  - 拿到dump文件后,我们可以使用JDK自带的VisualVM来进行dump文件分析,VisualVM可以帮我们看到错误信息和类信息、实例数,我们通过可以观察类和实例
  数的数量并结合错误信息,大致推测导致问题发生的类或代码段
  - 我们还可以用MAT(Memory Analyze),同样堆dump文件进行分析,该软件可以对线程的全生命周期进行分析,以及通过观察Shallow Heap和Retained Heap
  的数据情况来进行问题分析,sHeap表示对象本身在堆中占用的内存大小,而rHeap表示在垃圾回收时,如果删除该对象,该对象所保存的内存量;我们可以先观察各个
  线程对应的sHeap和rHeap的情况大致确定可能发生问题的线程,在通过进一步分析该线程生命周期的各个部分来定位问题成因;并且MAT还会为我们罗列几种问题怀
  疑,也可以帮助我们更快地定位问题原因

  ### 堆溢出问题的解决方案
  - 通过分析dump文件,来检查是否存在内存泄漏的问题
  - 如果没有找到明显的内存泄漏,使用 -Xmx增加最大堆内存


  ## 元空间溢出
  - 其内存回收的主要目标是针对常量池的回收和对类型的卸载

  ### 元空间溢出的原因
  - 元空间内存设置过小
  - 应用长时间运行,没有重启
  - 运行期间生成了大量的代理类,导致方法区被撑爆,无法卸载

  ### 元空间溢出的解决方案
  - 检查是否是元空间或永久代设置的过小
  - 检查代码中是否存在大量的反射操作
  - dump之后通过mat检查是否存在大量由于反射生产的代理类


  ## GC overhead limit exceeded
  - 一般是因为堆大小导致的,Sun官方对此的定义是: 超过98%的时间用来做GC并且回收了不到2%的堆内存时会抛出此异常,本质上是一个预判性的异常,抛出该异常
  时系统没有真正的内存溢出

  ### 解决方案
  - 检查代码中是否有死循环或使用大量内存(数组)的代码,优化代码
  - 添加参数[-XX:-UseGCOverheadLimit],禁用这个检查,但是这个动作并不解决问题,只是把错误信息延后,最终变成Java heap space
  - dump内存,检查是否出现内存泄漏,没有则加大内存


  ## 线程溢出, java.lang.OutOfMemoryError: unable to create new native Thread